1. Implement DFA accepting the language containing even binary numbers.
#include <stdio.h>
#include <string.h>
// Function to check if the binary number is even using DFA
int isEvenBinary(char *input) {
 int state = 0; // Start at state q0
 for (int i = 0; input[i] != '\0'; i++) {
 char symbol = input[i];
 if (symbol != '0' && symbol != '1') {
 printf("Invalid input: Only binary digits (0 and 1) are allowed.\n");
 return 0;
 }
 switch (state) {
 case 0: // q0
 if (symbol == '0')
 state = 0; // stay in q0
 else
 state = 1; // move to q1
 break;
 case 1: // q1
 if (symbol == '0')
 state = 0; // move to q0
 else
 state = 1; // stay in q1
 break;
 }
 }
 // Accepting state is q0 (state == 0)
 return state == 0;
}
int main() {
 char binary[100];
 printf("Enter a binary number: ");
 scanf("%s", binary);
 if (isEvenBinary(binary))
 printf("Accepted: The binary number is even.\n");
 else
 printf("Rejected: The binary number is odd.\n");
 return 0;
}

Sample Output:

Enter a binary number: 1010
Accepted: The binary number is even.
Enter a binary number: 111
Rejected: The binary number is odd.

2. Implement DFA that accept all the strings of a’s and b’s 3rd symbol from is RHS always a.
#include <stdio.h>
#include <string.h>
#define MAX_LEN 100
// Function to check if the 3rd symbol from right is 'a'
int checkThirdFromRightIsA(char *input) {
 int len = strlen(input);
 // A valid string must have at least 3 characters
 if (len < 3) {
 return 0; // Rejected
 }
 // Third character from the right is at position len - 3
 return input[len - 3] == 'a';
}
int main() {
 char input[MAX_LEN];
 printf("Enter a string over the alphabet {a, b}: ");
 scanf("%s", input);
 // Validate input characters
 for (int i = 0; input[i] != '\0'; i++) {
 if (input[i] != 'a' && input[i] != 'b') {
 printf("Invalid input: Only 'a' and 'b' are allowed.\n");
 return 1;
 }
 }
 if (checkThirdFromRightIsA(input))
 printf("Accepted: 3rd symbol from right is 'a'.\n");
 else
 printf("Rejected: 3rd symbol from right is not 'a'.\n");
 return 0;
}

Sample output:
Enter a string over the alphabet {a, b}: abba
Accepted: 3rd symbol from right is 'a'.
Enter a string over the alphabet {a, b}: abbb
Rejected: 3rd symbol from right is not 'a'.
Enter a string over the alphabet {a, b}: ab
Rejected: 3rd symbol from right is not 'a'.

3. Implement DFA accepting the language of strings not ending with 00 over the input (0,1)
3(I)

#include <stdio.h>

enum State { q0, q1, q2, q3 };

int isAccepted(char *input) {
    enum State state = q0;
    for (int i = 0; input[i]; i++) {
        if (input[i] != '0' && input[i] != '1') {
            printf("Invalid input: Only 0 and 1 are allowed.\n");
            return 0;
        }
        state = (state == q0) ? (input[i] == '0' ? q1 : q3) :
               (state == q1) ? (input[i] == '0' ? q2 : q3) :
               (state == q2) ? (input[i] == '0' ? q2 : q3) :
               (input[i] == '0' ? q1 : q3);
    }
    return state != q2;
}

int main() {
    char input[100];
    printf("Enter a binary string: ");
    scanf("%s", input);
    printf(isAccepted(input) ? "Accepted: String does NOT end with 00.\n" : "Rejected: String ends with 00.\n");
    return 0;
}

Sample output:
Enter a binary string (0s and 1s): 1010
Accepted: String does NOT end with 00.

3(II)

#include <stdio.h>
#include <string.h>
enum State { q0, q1, q2, q3 };
int isAccepted(char *input) {
 enum State state = q0;
 for (int i = 0; input[i] != '\0'; i++) {
 char symbol = input[i];
 if (symbol != '0' && symbol != '1') {
 printf("Invalid input: Only 0 and 1 are allowed.\n");
 return 0;
 }
 switch (state) {
 case q0:
 state = (symbol == '0') ? q1 : q3;
 break;
 case q1:
 state = (symbol == '0') ? q2 : q3;
 break;
 case q2:
 state = (symbol == '0') ? q2 : q3;
 break;
 case q3:
 state = (symbol == '0') ? q1 : q3;
 break;
 }
 }
 return state != q2;
}
int main() {
 char input[100];
 printf("Enter a binary string (0s and 1s): ");
 scanf("%s", input);
 if (isAccepted(input))
 printf("Accepted: String does NOT end with 00.\n");
 else
 printf("Rejected: String ends with 00.\n");
 return 0;
}

Sample output:
Enter a binary string (0s and 1s): 1010
Accepted: String does NOT end with 00.
Enter a binary string (0s and 1s): 1100
Rejected: String ends with 00.
Enter a binary string (0s and 1s): 1001
Accepted: String does NOT end with 00.

4. Implement the DFA that accepts all the string of a’s and b’s where number of a‘s is
divisible by 3 and number of b‘s is divisible by 2.
#include <stdio.h>
#include <string.h>
// DFA states
enum State {
 q0, q1, q2, q3, q4, q5
};
// Transition function
enum State transition(enum State current, char symbol) {
 switch (current) {
 case q0:
 return (symbol == 'a') ? q1 : q3;
 case q1:
 return (symbol == 'a') ? q2 : q4;
 case q2:
 return (symbol == 'a') ? q0 : q5;
 case q3:
9
 return (symbol == 'a') ? q4 : q0;
 case q4:
 return (symbol == 'a') ? q5 : q1;
 case q5:
 return (symbol == 'a') ? q3 : q2;
 default:
 return q0; // fallback
 }
}
int main() {
 char input[100];
 enum State state = q0;
 printf("Enter a string over the alphabet {a, b}: ");
 scanf("%s", input);
 // Validate input
 for (int i = 0; input[i]; i++) {
 if (input[i] != 'a' && input[i] != 'b') {
 printf("Invalid input: only 'a' and 'b' are allowed.\n");
 return 1;
 }
 state = transition(state, input[i]);
 }
 if (state == q0)
 printf("Accepted: Number of a's divisible by 3 and b's divisible by 2.\n");
 else
 printf("Rejected: Condition not satisfied.\n");
 return 0;
}
Sample output:
Enter a string over the alphabet {a, b}: aaabbaa
Accepted: Number of a's divisible by 3 and b's divisible by 2.
Enter a string over the alphabet {a, b}: aab
Rejected: Condition not satisfied.
10
5. Write lex program to implement lexical analyzer functionality.
%{
#include <stdio.h>
#include <string.h>
%}
%%
"if" { printf("Keyword: IF\n"); }
"else" { printf("Keyword: ELSE\n"); }
"while" { printf("Keyword: WHILE\n"); }
"for" { printf("Keyword: FOR\n"); }
"int" { printf("Keyword: INT\n"); }
"float" { printf("Keyword: FLOAT\n"); }
"return" { printf("Keyword: RETURN\n"); }
[0-9]+(\.[0-9]+)? { printf("Number: %s\n", yytext); }
[a-zA-Z_][a-zA-Z0-9_]* { printf("Identifier: %s\n", yytext); }
"==" { printf("Operator: ==\n"); }
"!=" { printf("Operator: !=\n"); }
"<=" { printf("Operator: <=\n"); }
">=" { printf("Operator: >=\n"); }
"=" { printf("Operator: =\n"); }
"<" { printf("Operator: <\n"); }
">" { printf("Operator: >\n"); }
"+" { printf("Operator: +\n"); }
"-" { printf("Operator: -\n"); }
"*" { printf("Operator: *\n"); }
"/" { printf("Operator: /\n"); }
";" { printf("Semicolon\n"); }
"," { printf("Comma\n"); }
"(" { printf("Left Parenthesis\n"); }
")" { printf("Right Parenthesis\n"); }
"{" { printf("Left Brace\n"); }
"}" { printf("Right Brace\n"); }
[ \t\n]+ { /* skip whitespace */ }
"//".* { /* skip single-line comment */ }
11
"/*"([^*]|\*+[^*/])*\*+"/" { /* skip multi-line comment */ }
. { printf("Unknown character: %s\n", yytext); }
%%
int main() {
 printf("Enter source code (Ctrl+D to end):\n");
 yylex();
 return 0;
}
int yywrap() {
 return 1;
}
How to Compile and Run:
lex lexer.l
gcc lex.yy.c -o lexer -ll
./lexer
Sample input:
int main() {
 int a = 5;
 if (a >= 5) {
 a = a + 1;
 }
}
Sample output:
Keyword: INT
Identifier: main
Left Parenthesis
Right Parenthesis
Left Brace
Keyword: INT
Identifier: a
Operator: =
Number: 5
Semicolon
Keyword: IF
12
Left Parenthesis
Identifier: a
Operator: >=
Number: 5
Right Parenthesis
Left Brace
Identifier: a
Operator: =
Identifier: a
Operator: +
Number: 1
Semicolon
Right Brace
Right Brace
6. Write a lex program to count the number of words and number of lines in a given file or
program.
%{
#include <stdio.h>
// Initialize counters
int word_count = 0;
int line_count = 0;
%}
%%
\n { line_count++; } // Increment line count
[ \t]+ { /* skip whitespace */ } // Skip spaces/tabs
[a-zA-Z0-9_]+ { word_count++; } // Count word tokens
. { /* skip other characters */ } // Skip everything else
%%
int main(int argc, char *argv[]) {
 if (argc > 1) {
 // Read from file if filename is given
 FILE *file = fopen(argv[1], "r");
 if (!file) {
 perror("File open failed");
 return 1;
13
 }
 yyin = file;
 }
 yylex(); // Start lexical analysis
 printf("Total Lines: %d\n", line_count);
 printf("Total Words: %d\n", word_count);
 return 0;
}
int yywrap() {
 return 1;
}
How to Compile and Run:
 Save this as count.l
 In terminal:
bash
CopyEdit
lex count.l
gcc lex.yy.c -o count -ll
 Run with a file:
bash
CopyEdit
./count filename.txt
Sample input:
This is a sample file.
It contains two lines.
Output:
Total Lines: 2
Total Words: 8
7. Write a ‘C’ program to implement lexical analyzer
#include <stdio.h>
14
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
char keywords[10][10] = {"int", "float", "if", "else", "while", "for", "return", "char", "double",
"void"};
int isKeyword(char *word) {
 for (int i = 0; i < 10; i++) {
 if (strcmp(word, keywords[i]) == 0)
 return 1;
 }
 return 0;
}
int main() {
 char ch, buffer[100];
 FILE *fp;
 int i = 0;
 fp = fopen("input.c", "r");
 if (fp == NULL) {
 printf("Error: Cannot open file\n");
 exit(1);
 }
 while ((ch = fgetc(fp)) != EOF) {
 // If it's a letter or digit, build a word/token
 if (isalnum(ch) || ch == '_') {
 buffer[i++] = ch;
 } else {
 if (i > 0) {
 buffer[i] = '\0';
 i = 0;
 if (isKeyword(buffer))
 printf("Keyword: %s\n", buffer);
 else if (isdigit(buffer[0]))
 printf("Number: %s\n", buffer);
 else
15
 printf("Identifier: %s\n", buffer);
 }
 // Handle operators and symbols
 if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '=' ||
 ch == '<' || ch == '>' || ch == '!' || ch == ';' ||
 ch == '(' || ch == ')' || ch == '{' || ch == '}' || ch == ',') {
 printf("Symbol: %c\n", ch);
 }
 }
 }
 fclose(fp);
 return 0;}.
Sample input.c File:
int main() {
 int a = 10, b = 20;
 if (a < b) {
 return a;
 }
}
Ouput:
Keyword: int
Identifier: main
Symbol: (
Symbol: )
Symbol: {
Keyword: int
Identifier: a
Symbol: =
Number: 10
Symbol: ,
Identifier: b
Symbol: =
Number: 20
Symbol: ;
Keyword: if
16
Symbol: (
Identifier: a
Symbol: <
Identifier: b
Symbol: )
Symbol: {
Keyword: return
Identifier: a
Symbol: ;
Symbol: }
Symbol: }
How to Use:
1. Save the code above as lexical_analyzer.c
2. Create a file named input.c with C code inside
3. Compile and run:
gcc lexical_analyzer.c -o lexer
./lexer
8. Write recursive descent parser for the grammar: E->E+T E->T T->T*F T->F F->(E)/id.
E → E + T | T
T → T * F | F
F → (E) | id
This grammar is left-recursive, which must be eliminated before writing a recursive descent parser.
Step 1: Remove Left Recursion
We transform the grammar to eliminate left recursion:
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε
F → (E) | id
17
Step 2: Write Recursive Descent Parser in C
#include <stdio.h>
#include <string.h>
#include <ctype.h>
char input[100];
int pos = 0;
void E(); // For E → T E'
void Eprime(); // For E'
void T(); // For T → F T'
void Tprime(); // For T'
void F(); // For F → (E) | id
void error() {
 printf("Syntax Error at position %d\n", pos);
 exit(1);
}
char peek() {
 return input[pos];
}
void match(char expected) {
 if (peek() == expected) {
 pos++;
 } else {
 error();
 }
}
// E → T E'
void E() {
 T();
 Eprime();
}
// E' → + T E' | ε
18
void Eprime() {
 if (peek() == '+') {
 match('+');
 T();
 Eprime();
 }
}
// T → F T'
void T() {
 F();
 Tprime();
}
// T' → * F T' | ε
void Tprime() {
 if (peek() == '*') {
 match('*');
 F();
 Tprime();
 }
}
// F → (E) | id
void F() {
 if (peek() == '(') {
 match('(');
 E();
 match(')');
 } else if (isalpha(peek())) { // id starts with letter
 while (isalnum(peek())) pos++; // consume full identifier
 } else {
 error();
 }
}
int main() {
 printf("Enter the expression: ");
 scanf("%s", input);
19
 E();
 if (input[pos] == '\0') {
 printf("Parsing successful: Valid expression.\n");
 } else {
 printf("Parsing failed: Extra symbols after valid expression.\n");
 }
 return 0;
}
Input: a+b*c
Output: Parsing successful: Valid expression.
9. Write recursive descent parser for the grammar: S->(L) S->a L->L,S L->S
Given Grammar:
S → (L) | a
L → L , S | S
This grammar is left-recursive due to L → L , S.
We must eliminate left recursion before writing the parser.
Step 1: Eliminate Left Recursion
Transform L → L , S | S into a right-recursive form:
S → (L) | a
L → S L'
L' → , S L' | ε
Step 2: Recursive Descent Parser in C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char input[100];
int pos = 0;
// Function declarations
20
void S();
void L();
void Lprime();
void error() {
 printf("Syntax Error at position %d\n", pos);
 exit(1);
}
char peek() {
 return input[pos];
}
void match(char expected) {
 if (peek() == expected) {
 pos++;
 } else {
 error();
 }
}
// S → (L) | a
void S() {
 if (peek() == '(') {
 match('(');
 L();
 match(')');
 } else if (peek() == 'a') {
 match('a');
 } else {
 error();
 }
}
// L → S L'
void L() {
 S();
 Lprime();
}
21
// L' → , S L' | ε
void Lprime() {
 if (peek() == ',') {
 match(',');
 S();
 Lprime();
 }
 // else ε (do nothing)
}
int main() {
 printf("Enter a string: ");
 scanf("%s", input);
 S();
 if (input[pos] == '\0') {
 printf("Parsing successful: Valid string.\n");
 } else {
 printf("Parsing failed: Extra characters after valid string.\n");
 }
 return 0;
}
Example Inputs & Results
Valid:
 a → ✔
 (a) → ✔
 (a,a) → ✔
 (a,(a,a)) → ✔
Invalid:
 ((a,a) → ✖(missing ))
 (a,a,) → ✖(comma with no right operand)
22
10. Write a C program to calculate first function for the grammar
 E->E+T E->T T->T*F T->FF->(E)/id
Given Grammar:
E → E + T | T
T → T * F | F
F → (E) | id
But this grammar has left recursion, which complicates computing FIRST sets with recursion.
Step 1: Eliminate Left Recursion
Left-recursion-free grammar:
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε
F → (E) | id
Step 2: Compute FIRST sets manually:
Now we compute FIRST sets for:
 FIRST(id) = { id }
 FIRST((E)) = { ( }, so FIRST(F) = { (, id }
 FIRST(T) = FIRST(F) = { (, id }
 FIRST(E) = FIRST(T) = { (, id }
Step 3: C Program to Compute FIRST Sets
Since this grammar is simple and does not involve left recursion anymore, we can hardcode
productions and recursively compute FIRST sets.
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
23
#define MAX 10
char productions[MAX][20];
char first[MAX][20];
int n;
bool isTerminal(char symbol) {
 return !(symbol >= 'A' && symbol <= 'Z');
}
void findFirst(int i, char result[]) {
 char *prod = productions[i];
 int k = 3; // skip "A->"
 if (prod[k] == '\0') return;
 // handle multiple alternatives A->x|y
 while (prod[k]) {
 if (isTerminal(prod[k])) {
 strncat(result, &prod[k], 1);
 } else {
 // Non-terminal: find FIRST of non-terminal
 for (int j = 0; j < n; j++) {
 if (productions[j][0] == prod[k]) {
 char temp[20] = "";
 findFirst(j, temp);
 strcat(result, temp);
 }
 }
 }
 // skip to next alternative or end
 while (prod[k] && prod[k] != '|') k++;
 if (prod[k] == '|') k++;
 }
}
void removeDuplicates(char *str) {
 int index = 0;
24
 int len = strlen(str);
 for (int i = 0; i < len; i++) {
 int j;
 for (j = 0; j < i; j++) {
 if (str[i] == str[j])
 break;
 }
 if (j == i)
 str[index++] = str[i];
 }
 str[index] = '\0';
}
int main() {
 printf("Enter number of productions: ");
 scanf("%d", &n);
 getchar(); // consume newline
 for (int i = 0; i < n; i++) {
 printf("Enter production %d (e.g. E->T+E): ", i + 1);
 gets(productions[i]);
 }
 printf("\nFIRST sets:\n");
 for (int i = 0; i < n; i++) {
 char result[20] = "";
 findFirst(i, result);
 removeDuplicates(result);
 printf("FIRST(%c) = { ", productions[i][0]);
 for (int j = 0; j < strlen(result); j++) {
 printf("%c", result[j]);
 if (j < strlen(result) - 1)
 printf(", ");
 }
 printf(" }\n");
 }
 return 0;
}
25
Sample Input:
Enter number of productions: 5
Enter production 1: E->TE'
Enter production 2: E'->+TE'|ε
Enter production 3: T->FT'
Enter production 4: T'->*FT'|ε
Enter production 5: F->(E)|id
Output:
FIRST(E) = { (, i, d }
FIRST(E') = { +, ε }
FIRST(T) = { (, i, d }
FIRST(T') = { *, ε }
FIRST(F) = { (, i, d }
11. Write a YACC program to implement top down parser for the given grammar.
Grammar:
S → (L) | a
L → L , S | S
This is a simple LL(1)-friendly grammar (after removing left recursion), and we can use YACC along with
Lex to build a parser for it.
Complete Working Lex and YACC Program
We'll use:
 Lex to tokenize the input ((, ), ,, a)
 YACC to define the grammar and parsing logic
parser.l — Lex Program
%{
#include "y.tab.h"
%}
%%
"(" { return LPAREN; }
")" { return RPAREN; }
"," { return COMMA; }
26
"a" { return ID; }
[ \t\n] ; // Ignore whitespace
. { printf("Invalid character: %s\n", yytext); return -1; }
%%
parser.y — YACC Program
%{
#include <stdio.h>
#include <stdlib.h>
%}
%token ID LPAREN RPAREN COMMA
%%
S : LPAREN L RPAREN
 | ID
 ;
L : S L1
 ;
L1 : COMMA S L1
 | /* ε (empty) */
 ;
%%
int main() {
 printf("Enter input string:\n");
 return yyparse();
}
void yyerror(const char *msg) {
 fprintf(stderr, "Parse error: %s\n", msg);
}
Build & Run Instructions:
1. Save Lex code as parser.l
27
2. Save YACC code as parser.y
3. Compile and run using:
yacc -d parser.y
lex parser.l
gcc y.tab.c lex.yy.c -o parser
./parser
Sample Inputs:
Valid Inputs:
a
(a)
(a,a)
(a,(a,a))
Invalid Inputs:
((a,a)
a,)
(,)
Output:
If input is valid:
Enter input string:
(a,a)
It finishes silently (indicating success).
If there's an error:
Enter input string:
(a,)
Parse error: syntax error
12. Write a YACC program to evaluate algebraic expression.
28
Here's a complete YACC program to evaluate algebraic expressions using Lex and YACC.
It supports:
 Operators: +, -, *, /, ()
 Integer numbers
 Operator precedence and associativity
Step-by-step Lex & YACC Programs
expr.l — Lex Program (Tokenizer)
%{
#include "y.tab.h"
%}
%%
[0-9]+ { yylval = atoi(yytext); return NUMBER; }
[\t ]+ ; // ignore spaces and tabs
\n { return '\n'; }
"+" { return '+'; }
"-" { return '-'; }
"*" { return '*'; }
"/" { return '/'; }
"(" { return '('; }
")" { return ')'; }
. { printf("Invalid character: %s\n", yytext); return -1; }
29
%%
expr.y — YACC Program (Parser + Evaluator)
%{
#include <stdio.h>
#include <stdlib.h>
%}
%token NUMBER
%left '+' '-'
%left '*' '/'
%right UMINUS
%%
input:
 /* empty */
 | input line
 ;
line:
 expr '\n' { printf("Result = %d\n", $1); }
 ;
30
expr:
 expr '+' expr { $$ = $1 + $3; }
 | expr '-' expr { $$ = $1 - $3; }
 | expr '*' expr { $$ = $1 * $3; }
 | expr '/' expr {
 if ($3 == 0) {
 printf("Error: Division by zero\n");
 exit(1);
 }
 $$ = $1 / $3;
 }
 | '-' expr %prec UMINUS { $$ = -$2; }
 | '(' expr ')' { $$ = $2; }
 | NUMBER { $$ = $1; }
 ;
%%
int main() {
 printf("Enter arithmetic expressions (e.g., 2 + 3 * (4 - 1)):\n");
 yyparse();
 return 0;
}
31
void yyerror(const char *s) {
 printf("Syntax error: %s\n", s);
}
Build & Run Instructions
1. Save the lex code as expr.l
2. Save the yacc code as expr.y
3. Open terminal and compile:
yacc -d expr.y
lex expr.l
gcc y.tab.c lex.yy.c -o calc
./calc
Sample Run:
Enter arithmetic expressions (e.g., 2 + 3 * (4 - 1)):
2 + 3 * (4 - 1)
Result = 11
10 / (2 + 3)
Result = 2
-5 + 2
Result = -3
