1. Implement Substitution Cipher.
Aim: To Implement substitution cipher.
Program:
import java.io.*;
import java.util.*;
public class SubstitutionCipher
{
static Scanner sc=new Scanner(System.in);
static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
public static void main(String[] args)throws IOException
{
String a="abcdefghijklmnopqrstuvwxyz";
String b="zyxwvutsrqponmlkjihgfedcba";
System.out.println("Enter any string:");
String str=br.readLine();
String decrypt="";
char c;
for(int i=0;i<str.length();i++)
{
c=str.charAt(i);
int j=a.indexOf(c);
decrypt=decrypt+b.charAt(j);
{
System.out.println("the encrypted data is:"+decrypt);
}
}
}
}

2. Implement Transposition Cipher
Aim:To understand the concept of Transposition cipher.
Program:
import java.util.*;
class SimpleColumnar{
 public static void main(String sap[]){
 Scanner sc = new Scanner(System.in);
 System.out.print("\nEnter plaintext(enter in lower case): ");
 String message = sc.next();
 System.out.print("\nEnter key in numbers: ");
 String key = sc.next();
 /* columnCount would keep track of columns */
 int columnCount = key.length();
 /* rowCount will keep of track of rows...no of rows = (plaintextlength + keylength) /
keylength */
 int rowCount = (message.length()+columnCount)/columnCount;
 /*plainText and cipherText would be array containing ASCII values for respective
alphabets */
 int plainText[][] = new int[rowCount][columnCount];
 int cipherText[][] = new int[rowCount][columnCount];
 /*Encryption Process*/
 System.out.print("\n-----Encryption-----\n");
 cipherText = encrypt(plainText, cipherText, message, rowCount, columnCount, key);
 // prepare final string
 String ct = "";
 for(int i=0; i<columnCount; i++)
 {
 for(int j=0; j<rowCount; j++)
 {
 if(cipherText[j][i] == 0)
 ct = ct + 'x';
 else{
 ct = ct + (char)cipherText[j][i];
 }
 }
 } System.out.print("\nCipher Text: " + ct);
 /*Decryption Process*/
 System.out.print("\n\n\n-----Decryption-----\n");
 plainText = decrypt(plainText, cipherText, ct, rowCount, columnCount, key);
 // prepare final string
 String pt = "";
 for(int i=0; i<rowCount; i++)
 {
 for(int j=0; j<columnCount; j++)
 {
 if(plainText[i][j] == 0)
 pt = pt + "";
 else{
 pt = pt + (char)plainText[i][j];
 }
 }
 }
 System.out.print("\nPlain Text: " + pt);
 System.out.println();
 }
 static int[][] encrypt(int plainText[][], int cipherText[][], String message, int rowCount,
int columnCount, String key){
 int i,j;
 int k=0;
 /* here array would be filled row by row */
 for(i=0; i<rowCount; i++)
 {
 for(j=0; j<columnCount; j++)
 {
 /* terminating condition...as string length can be smaller than 2-D array */
 if(k < message.length())
 {
 /* respective ASCII characters would be placed */
 plainText[i][j] = (int)message.charAt(k);
36
 k++;
 }
 else
 {
 break;
 }
 }
 }
 /* here array would be filled according to the key column by column */
 for(i=0; i<columnCount; i++)
 {
 /* currentCol would have current column number i.e. to be read...as there
would be ASCII value stored in key so we would subtract it by 48 so that we can get the
original number...and -1 would be subtract as array position starts from 0*/
int currentCol= ( (int)key.charAt(i) - 48 ) -1;
 for(j=0; j<rowCount; j++)
 {
 cipherText[j][i] = plainText[j][currentCol];
 }
 }
 System.out.print("Cipher Array(read column by column): \n");
 for(i=0;i<rowCount;i++){
 for(j=0;j<columnCount;j++){
 System.out.print((char)cipherText[i][j]+"\t");
 }
 System.out.println();
 }
 return cipherText;
 }
 static int[][] decrypt(int plainText[][], int cipherText[][], String message, int rowCount,
int columnCount, String key){
 int i,j;
 int k=0;
 for(i=0; i<columnCount; i++)
 {
 int currentCol= ( (int)key.charAt(i) - 48 ) -1;
 for(j=0; j<rowCount; j++)
 {
 plainText[j][currentCol] = cipherText[j][i];
 }
 }
 System.out.print("Plain Array(read row by row): \n");
 for(i=0;i<rowCount;i++){
 for(j=0;j<columnCount;j++){
 System.out.print((char)plainText[i][j]+"\t");
 }
 System.out.println();
 }
 return plainText;
 }
}

3.Implement DES
 (a)Generate Cipher text for the given Plaintext.
 (b)Retrieve the Plaintext from the given Ciphertext.

3(I)

import javax.swing.*;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.util.*;

public class DES {
    private static byte[] key;

    public static void main(String[] args) {
            KeyGenerator keyGen = KeyGenerator.getInstance("DES");
            keyGen.init(56, new SecureRandom());
            SecretKey secretKey = keyGen.generateKey();
            key = secretKey.getEncoded();
            System.out.println("DES Key: " + new String(key));
            String message = JOptionPane.showInputDialog("Enter message to encrypt:");
            byte[] encrypted = encrypt(message.getBytes());
            String encryptedText = Base64.getEncoder().encodeToString(encrypted);
            JOptionPane.showMessageDialog(null, "Encrypted:\n" + encryptedText);
            byte[] decrypted = decrypt(Base64.getDecoder().decode(encryptedText));
            JOptionPane.showMessageDialog(null, "Decrypted:\n" + new String(decrypted));
        } 

    private static byte[] encrypt(byte[] clear) throws Exception {
        Cipher cipher = Cipher.getInstance("DES");
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "DES"));
        return cipher.doFinal(clear);
    }

    private static byte[] decrypt(byte[] encrypted) throws Exception {
        Cipher cipher = Cipher.getInstance("DES");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "DES"));
        return cipher.doFinal(encrypted);
    }
}

3(II)

Aim:To Understand the DES Algorithm .
Program :
import javax.swing.*;
import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Random ;
class DES {
byte[] skey = new byte[1000];
String skeyString;
static byte[] raw;
String inputMessage, encryptedData,decryptedMessage;
public DES() {
try {
generateSymmetricKey();
inputMessage=JOptionPane.showInputDialog(null,"Enter message to encrypt");
byte[] ibyte = inputMessage.getBytes();
byte[] ebyte=encrypt(raw, ibyte);
String encryptedData = new String(ebyte);
System.out.println("Encrypted message "+encryptedData);
JOptionPane.showMessageDialog(null,"Encrypted Data
"+"\n"+encryptedData);
byte[] dbyte= decrypt(raw,ebyte);
String decryptedMessage = new String(dbyte);
System.out.println("Decrypted message "+decryptedMessage);
JOptionPane.showMessageDialog(null,"Decrypted Data
"+"\n"+decryptedMessage);
}
catch(Exception e) {
System.out.println(e);
}
}
void generateSymmetricKey() {
39
try {
Random r = new Random();
int num = r.nextInt(10000);
String knum = String.valueOf(num);
byte[] knumb = knum.getBytes();
skey=getRawKey(knumb);
skeyString = new String(skey);
System.out.println("DES Symmetric key = "+skeyString);
}
catch(Exception e) {
System.out.println(e);
}
}
private static byte[] getRawKey(byte[] seed) throws Exception {
KeyGenerator kgen = KeyGenerator.getInstance("DES");
SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
sr.setSeed(seed);
kgen.init(56, sr);
SecretKey skey = kgen.generateKey();
raw = skey.getEncoded();
return raw;
}
private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
SecretKeySpec skeySpec = new SecretKeySpec(raw, "DES");
Cipher cipher = Cipher.getInstance("DES");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
byte[] encrypted = cipher.doFinal(clear);
return encrypted;
}
private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
SecretKeySpec skeySpec = new SecretKeySpec(raw, "DES");
Cipher cipher = Cipher.getInstance("DES");
cipher.init(Cipher.DECRYPT_MODE, skeySpec);
byte[] decrypted = cipher.doFinal(encrypted);
return decrypted;
}
public static void main(String args[]) {
DES des = new DES();
}
}


4.Implement Diffie Hellman Algorithm and generate Secret Key.
Aim:To Understand the Diffie Hellman algorithm.
Program:
import java.math.BigInteger;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.SecureRandom;
import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.DHPublicKeySpec;
public class DiffeHellman
{
public final static int pValue = 47;
public final static int gValue = 71;
public final static int XaValue = 9;
public final static int XbValue = 14;
public static void main(String[] args) throws Exception
{
BigInteger p = new BigInteger(Integer.toString(pValue));
41
BigInteger g = new BigInteger(Integer.toString(gValue));
BigInteger Xa = new BigInteger(Integer.toString(XaValue));
BigInteger Xb = new BigInteger(Integer.toString(XbValue));
createKey();
int bitLength = 512;
SecureRandom rnd = new SecureRandom();
p = BigInteger.probablePrime(bitLength, rnd);
g = BigInteger.probablePrime(bitLength, rnd);
createSpecificKey(p, g);
}
public static void createKey() throws Exception
{
KeyPairGenerator kpg = KeyPairGenerator.getInstance("DiffieHellman");
kpg.initialize(512);
KeyPair kp = kpg.generateKeyPair();
KeyFactory kfactory = KeyFactory.getInstance("DiffieHellman");
DHPublicKeySpec kspec = (DHPublicKeySpec) kfactory.getKeySpec(kp.getPublic(),
DHPublicKeySpec.class);
System.out.println("Public key is: " +kspec);
}
public static void createSpecificKey(BigInteger p, BigInteger g) throws Exception
{
KeyPairGenerator kpg = KeyPairGenerator.getInstance("DiffieHellman");
DHParameterSpec param = new DHParameterSpec(p, g);
kpg.initialize(param);
KeyPair kp = kpg.generateKeyPair();
KeyFactory kfactory = KeyFactory.getInstance("DiffieHellman");
DHPublicKeySpec kspec = (DHPublicKeySpec) kfactory.getKeySpec(kp.getPublic(),
DHPublicKeySpec.class);
42
System.out.println("\nPublic key is : " +kspec);
}
}
OUTPUT:
5.Implement RSA algorithm
a)Generate Public key and Private key pair
b)Generate Ciphertext for the Plaintext
c)Obtain the Plaintext from the Ciphertext
Aim: To understand the RSA Algorithm.
Program:
import java.util.*;
import java.math.*;
class RSA1
{
public static void main(String args[])
{
Scanner sc=new Scanner(System.in);
int p,q,n,z,d=0,e,i;
System.out.println("Enter the number to be encrypted and decrypted");
int msg=sc.nextInt();
double c;
BigInteger msgback;
System.out.println("Enter 1st prime number p");
p=sc.nextInt();
43
System.out.println("Enter 2nd prime number q");
q=sc.nextInt();
n=p*q;
z=(p-1)*(q-1);
System.out.println("the value of z = "+z);
for(e=2;e<z;e++)
{
if(gcd(e,z)==1) // e is for public key exponent
{
break;
}
}
System.out.println("the value of e = "+e);
for(i=0;i<=9;i++)
{
int x=1+(i*z);
if(x%e==0) //d is for private key exponent
{
d=x/e;
break;
}
}
System.out.println("the value of d = "+d);
c=(Math.pow(msg,e))%n;
System.out.println("Encrypted message is : -");
System.out.println(c);
 //converting int value of n to BigInteger
BigInteger N = BigInteger.valueOf(n);
//converting float value of c to BigInteger
BigInteger C = BigDecimal.valueOf(c).toBigInteger();
msgback = (C.pow(d)).mod(N);
System.out.println("Derypted message is : -");
System.out.println(msgback);
}
static int gcd(int e, int z)
44
{
if(e==0)
return z;
else
return gcd(z%e,e);
}
}
OUTPUT:
6. Implement Hash Algorithm
Aim:To understand the Hashing Technique.
Program:
class MD5
{ import java.security.*;
public
public static void main(String[] a)
{
try
{
MessageDigest md = MessageDigest.getInstance("MD5");
System.out.println("Message digest object info: ");
System.out.println(" Algorithm = " +md.getAlgorithm());
45
System.out.println(" Provider = " +md.getProvider());
System.out.println(" ToString = " +md.toString());
String input = "";
md.update(input.getBytes());
byte[] output = md.digest();
System.out.println();
System.out.println("MD5(\""+input+"\") = " +bytesToHex(output));
input = "abc";
md.update(input.getBytes());
output = md.digest();
System.out.println();
System.out.println("MD5(\""+input+"\") = " +bytesToHex(output));
input = "abcdefghijklmnopqrstuvwxyz";
md.update(input.getBytes());
output = md.digest();
System.out.println();
System.out.println("MD5(\"" +input+"\") = " +bytesToHex(output));
System.out.println("");
}
catch (Exception e) { System.out.println("Exception: " +e); }
}
public static String bytesToHex(byte[] b)
{
char hexDigit[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
StringBuffer buf = new StringBuffer();
for (int j=0; j<b.length; j++)
{
buf.append(hexDigit[(b[j] >> 4) & 0x0f]);
buf.append(hexDigit[b[j] & 0x0f]);
46
}
return buf.toString();
}
}
OUTPUT:
7. Generate Digital Signature
Aim:To Generate the Digital signature .
Program:
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.Signature;
import sun.misc.BASE64Encoder;
public class DigSign {
public static void main(String[] args) throws Exception {
// TODO code application logic here
KeyPairGeneratorkpg = KeyPairGenerator.getInstance("RSA");
kpg.initialize(1024);
47
KeyPairkeyPair = kpg.genKeyPair();
byte[] data = "Sample Text".getBytes("UTF8");
Signature sig = Signature.getInstance("MD5WithRSA");
sig.initSign(keyPair.getPrivate());
sig.update(data);
byte[] signatureBytes = sig.sign();
System.out.println("Signature: \n" + new BASE64Encoder().encode(signatureBytes));
sig.initVerify(keyPair.getPublic());
sig.update(data);
System.out.println(sig.verify(signatureBytes));
}
}
OUTPUT:
8. Implement Digital Envelope
Aim:To Implement Digital Envelope.
Program:
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
public class DSAKeyGen
{
48
public static void main(String[] args) throws Exception
{
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
keyGen.initialize(1024);
KeyPair keypair = keyGen.genKeyPair();
PrivateKey privateKey = keypair.getPrivate();
System.out.println(privateKey);
PublicKey publicKey = keypair.getPublic();
System.out.println(publicKey);
}
}
